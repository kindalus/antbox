import { describe, it } from "bdd";
import { expect } from "expect";
import type { AuthenticationContext } from "application/authentication_context.ts";
import { InMemoryConfigurationRepository } from "adapters/inmem/inmem_configuration_repository.ts";
import { WorkflowInstancesService } from "application/workflow_instances_service.ts";
import { WorkflowsService } from "application/workflows_service.ts";
import { ADMINS_GROUP_UUID } from "domain/configuration/builtin_groups.ts";

describe("WorkflowInstancesService", () => {
	// Mock dependencies for service construction
	const mockNodeService = null as any;
	const mockFeatureService = null as any;

	const adminCtx: AuthenticationContext = {
		tenant: "test",
		principal: {
			email: "admin@example.com",
			groups: [ADMINS_GROUP_UUID],
		},
		mode: "Action",
	};

	const userCtx: AuthenticationContext = {
		tenant: "test",
		principal: {
			email: "user@example.com",
			groups: ["--users--"],
		},
		mode: "Action",
	};

	const editorCtx: AuthenticationContext = {
		tenant: "test",
		principal: {
			email: "editor@example.com",
			groups: ["--editors--"],
		},
		mode: "Action",
	};

	// TODO: These tests need to be rewritten to use startWorkflow instead of createWorkflowInstance
	// The new WorkflowInstancesService uses startWorkflow which requires node locking and validation
	describe.skip("createWorkflowInstance", () => {
		it("should create workflow instance successfully with permission", async () => {
			const repo = new InMemoryConfigurationRepository();
			const workflowsService = new WorkflowsService(repo);
			const service = new WorkflowInstancesService(
				repo,
				mockNodeService,
				workflowsService,
				mockFeatureService,
			);

			// First create a workflow
			const workflowResult = await workflowsService.createWorkflow(adminCtx, {
				title: "Article Review",
				description: "Article review workflow",
				states: [
					{
						name: "draft",
						isInitial: true,
						transitions: [{ signal: "submit", targetState: "review" }],
					},
					{ name: "review", isFinal: true },
				],
				availableStateNames: ["draft", "review"],
				filters: [["mimetype", "==", "text/markdown"]],
				groupsAllowed: ["--editors--"],
			});

			expect(workflowResult.isRight()).toBe(true);
			if (!workflowResult.isRight()) return;
			const workflow = workflowResult.value;

			// Create instance
			const result = await service.createWorkflowInstance(editorCtx, {
				workflowDefinitionUuid: workflow.uuid,
				nodeUuid: "node-123",
				groupsAllowed: ["--editors--"],
			});

			expect(result.isRight()).toBe(true);
			if (result.isRight()) {
				const instance = result.value;
				expect(instance.workflowDefinitionUuid).toBe(workflow.uuid);
				expect(instance.nodeUuid).toBe("node-123");
				expect(instance.currentStateName).toBe("draft");
				expect(instance.running).toBe(true);
				expect(instance.cancelled).toBe(false);
				expect(instance.history.length).toBe(0);
				expect(instance.owner).toBe("editor@example.com");
			}
		});

		it("should reject creation without permission", async () => {
			const repo = new InMemoryConfigurationRepository();
			const workflowsService = new WorkflowsService(repo);
			const service = new WorkflowInstancesService(
				repo,
				mockNodeService,
				workflowsService,
				mockFeatureService,
			);

			// Create workflow with editors-only permission
			const workflowResult = await workflowsService.createWorkflow(adminCtx, {
				title: "Article Review",
				description: "Article review workflow",
				states: [
					{
						name: "draft",
						isInitial: true,
						transitions: [{ signal: "submit", targetState: "review" }],
					},
					{ name: "review", isFinal: true },
				],
				availableStateNames: ["draft", "review"],
				filters: [["mimetype", "==", "text/markdown"]],
				groupsAllowed: ["--editors--"],
			});

			expect(workflowResult.isRight()).toBe(true);
			if (!workflowResult.isRight()) return;
			const workflow = workflowResult.value;

			// Try to create instance as regular user (not in editors group)
			const result = await service.createWorkflowInstance(userCtx, {
				workflowDefinitionUuid: workflow.uuid,
				nodeUuid: "node-123",
				groupsAllowed: ["--editors--"],
			});

			expect(result.isLeft()).toBe(true);
		});

		it("should reject creation with non-existent workflow", async () => {
			const repo = new InMemoryConfigurationRepository();
			const service = new WorkflowInstancesService(
				repo,
				mockNodeService,
				workflowsService,
				mockFeatureService,
			);

			const result = await service.createWorkflowInstance(adminCtx, {
				workflowDefinitionUuid: "non-existent",
				nodeUuid: "node-123",
				groupsAllowed: [],
			});

			expect(result.isLeft()).toBe(true);
		});
	});

	describe("getWorkflowInstance", () => {
		it("should get workflow instance with permission", async () => {
			const repo = new InMemoryConfigurationRepository();
			const workflowsService = new WorkflowsService(repo);
			const service = new WorkflowInstancesService(
				repo,
				mockNodeService,
				workflowsService,
				mockFeatureService,
			);

			// Create workflow and instance
			const workflowResult = await workflowsService.createWorkflow(adminCtx, {
				title: "Article Review",
				description: "Article review workflow",
				states: [
					{
						name: "draft",
						isInitial: true,
						transitions: [{ signal: "submit", targetState: "review" }],
					},
					{ name: "review", isFinal: true },
				],
				availableStateNames: ["draft", "review"],
				filters: [["mimetype", "==", "text/markdown"]],
				groupsAllowed: ["--editors--"],
			});

			expect(workflowResult.isRight()).toBe(true);
			if (!workflowResult.isRight()) return;

			const createResult = await service.createWorkflowInstance(editorCtx, {
				workflowDefinitionUuid: workflowResult.value.uuid,
				nodeUuid: "node-123",
				groupsAllowed: ["--editors--"],
			});

			expect(createResult.isRight()).toBe(true);
			if (!createResult.isRight()) return;

			// Get instance
			const result = await service.getWorkflowInstance(editorCtx, createResult.value.uuid);

			expect(result.isRight()).toBe(true);
			if (result.isRight()) {
				expect(result.value.uuid).toBe(createResult.value.uuid);
			}
		});

		it("should reject get without permission", async () => {
			const repo = new InMemoryConfigurationRepository();
			const workflowsService = new WorkflowsService(repo);
			const service = new WorkflowInstancesService(
				repo,
				mockNodeService,
				workflowsService,
				mockFeatureService,
			);

			// Create workflow and instance
			const workflowResult = await workflowsService.createWorkflow(adminCtx, {
				title: "Article Review",
				description: "Article review workflow",
				states: [
					{
						name: "draft",
						isInitial: true,
						transitions: [{ signal: "submit", targetState: "review" }],
					},
					{ name: "review", isFinal: true },
				],
				availableStateNames: ["draft", "review"],
				filters: [["mimetype", "==", "text/markdown"]],
				groupsAllowed: ["--editors--"],
			});

			expect(workflowResult.isRight()).toBe(true);
			if (!workflowResult.isRight()) return;

			const createResult = await service.createWorkflowInstance(editorCtx, {
				workflowDefinitionUuid: workflowResult.value.uuid,
				nodeUuid: "node-123",
				groupsAllowed: ["--editors--"],
			});

			expect(createResult.isRight()).toBe(true);
			if (!createResult.isRight()) return;

			// Try to get instance as user without permission
			const result = await service.getWorkflowInstance(userCtx, createResult.value.uuid);

			expect(result.isLeft()).toBe(true);
		});
	});

	describe("getWorkflowInstanceByNodeUuid", () => {
		it("should find workflow instance by node UUID", async () => {
			const repo = new InMemoryConfigurationRepository();
			const workflowsService = new WorkflowsService(repo);
			const service = new WorkflowInstancesService(
				repo,
				mockNodeService,
				workflowsService,
				mockFeatureService,
			);

			// Create workflow and instance
			const workflowResult = await workflowsService.createWorkflow(adminCtx, {
				title: "Article Review",
				description: "Article review workflow",
				states: [
					{
						name: "draft",
						isInitial: true,
						transitions: [{ signal: "submit", targetState: "review" }],
					},
					{ name: "review", isFinal: true },
				],
				availableStateNames: ["draft", "review"],
				filters: [["mimetype", "==", "text/markdown"]],
				groupsAllowed: [],
			});

			expect(workflowResult.isRight()).toBe(true);
			if (!workflowResult.isRight()) return;

			const createResult = await service.createWorkflowInstance(adminCtx, {
				workflowDefinitionUuid: workflowResult.value.uuid,
				nodeUuid: "node-456",
				groupsAllowed: [],
			});

			expect(createResult.isRight()).toBe(true);
			if (!createResult.isRight()) return;

			// Find by node UUID
			const result = await service.getWorkflowInstanceByNodeUuid(adminCtx, "node-456");

			expect(result.isRight()).toBe(true);
			if (result.isRight()) {
				expect(result.value.nodeUuid).toBe("node-456");
			}
		});

		it("should return NotFoundError when no instance exists for node", async () => {
			const repo = new InMemoryConfigurationRepository();
			const service = new WorkflowInstancesService(
				repo,
				mockNodeService,
				workflowsService,
				mockFeatureService,
			);

			const result = await service.getWorkflowInstanceByNodeUuid(adminCtx, "non-existent-node");

			expect(result.isLeft()).toBe(true);
		});
	});

	describe("listWorkflowInstances", () => {
		it("should list all instances for admin", async () => {
			const repo = new InMemoryConfigurationRepository();
			const workflowsService = new WorkflowsService(repo);
			const service = new WorkflowInstancesService(
				repo,
				mockNodeService,
				workflowsService,
				mockFeatureService,
			);

			// Create workflow
			const workflowResult = await workflowsService.createWorkflow(adminCtx, {
				title: "Article Review",
				description: "Article review workflow",
				states: [
					{
						name: "draft",
						isInitial: true,
						transitions: [{ signal: "submit", targetState: "review" }],
					},
					{ name: "review", isFinal: true },
				],
				availableStateNames: ["draft", "review"],
				filters: [["mimetype", "==", "text/markdown"]],
				groupsAllowed: ["--editors--"],
			});

			expect(workflowResult.isRight()).toBe(true);
			if (!workflowResult.isRight()) return;

			// Create two instances
			await service.createWorkflowInstance(adminCtx, {
				workflowDefinitionUuid: workflowResult.value.uuid,
				nodeUuid: "node-1",
				groupsAllowed: ["--editors--"],
			});

			await service.createWorkflowInstance(adminCtx, {
				workflowDefinitionUuid: workflowResult.value.uuid,
				nodeUuid: "node-2",
				groupsAllowed: ["--users--"],
			});

			// Admin should see both
			const result = await service.listWorkflowInstances(adminCtx);

			expect(result.isRight()).toBe(true);
			if (result.isRight()) {
				expect(result.value.length).toBe(2);
			}
		});

		it("should list only permitted instances for non-admin", async () => {
			const repo = new InMemoryConfigurationRepository();
			const workflowsService = new WorkflowsService(repo);
			const service = new WorkflowInstancesService(
				repo,
				mockNodeService,
				workflowsService,
				mockFeatureService,
			);

			// Create workflow
			const workflowResult = await workflowsService.createWorkflow(adminCtx, {
				title: "Article Review",
				description: "Article review workflow",
				states: [
					{
						name: "draft",
						isInitial: true,
						transitions: [{ signal: "submit", targetState: "review" }],
					},
					{ name: "review", isFinal: true },
				],
				availableStateNames: ["draft", "review"],
				filters: [["mimetype", "==", "text/markdown"]],
				groupsAllowed: [],
			});

			expect(workflowResult.isRight()).toBe(true);
			if (!workflowResult.isRight()) return;

			// Create three instances with different permissions
			await service.createWorkflowInstance(adminCtx, {
				workflowDefinitionUuid: workflowResult.value.uuid,
				nodeUuid: "node-1",
				groupsAllowed: ["--editors--"],
			});

			await service.createWorkflowInstance(adminCtx, {
				workflowDefinitionUuid: workflowResult.value.uuid,
				nodeUuid: "node-2",
				groupsAllowed: ["--users--"],
			});

			await service.createWorkflowInstance(adminCtx, {
				workflowDefinitionUuid: workflowResult.value.uuid,
				nodeUuid: "node-3",
				groupsAllowed: [],
			});

			// Editor should see editors instance and public instance
			const editorResult = await service.listWorkflowInstances(editorCtx);

			expect(editorResult.isRight()).toBe(true);
			if (editorResult.isRight()) {
				expect(editorResult.value.length).toBe(2);
			}

			// User should see users instance and public instance
			const userResult = await service.listWorkflowInstances(userCtx);

			expect(userResult.isRight()).toBe(true);
			if (userResult.isRight()) {
				expect(userResult.value.length).toBe(2);
			}
		});
	});

	describe("updateWorkflowInstance", () => {
		it("should update workflow instance with permission", async () => {
			const repo = new InMemoryConfigurationRepository();
			const workflowsService = new WorkflowsService(repo);
			const service = new WorkflowInstancesService(
				repo,
				mockNodeService,
				workflowsService,
				mockFeatureService,
			);

			// Create workflow and instance
			const workflowResult = await workflowsService.createWorkflow(adminCtx, {
				title: "Article Review",
				description: "Article review workflow",
				states: [
					{
						name: "draft",
						isInitial: true,
						transitions: [{ signal: "submit", targetState: "review" }],
					},
					{ name: "review", isFinal: true },
				],
				availableStateNames: ["draft", "review"],
				filters: [["mimetype", "==", "text/markdown"]],
				groupsAllowed: ["--editors--"],
			});

			expect(workflowResult.isRight()).toBe(true);
			if (!workflowResult.isRight()) return;

			const createResult = await service.createWorkflowInstance(editorCtx, {
				workflowDefinitionUuid: workflowResult.value.uuid,
				nodeUuid: "node-123",
				groupsAllowed: ["--editors--"],
			});

			expect(createResult.isRight()).toBe(true);
			if (!createResult.isRight()) return;

			// Update instance
			const result = await service.updateWorkflowInstance(
				editorCtx,
				createResult.value.uuid,
				{
					currentStateName: "review",
					running: false,
				},
			);

			expect(result.isRight()).toBe(true);
			if (result.isRight()) {
				expect(result.value.currentStateName).toBe("review");
				expect(result.value.running).toBe(false);
			}
		});

		it("should reject update without permission", async () => {
			const repo = new InMemoryConfigurationRepository();
			const workflowsService = new WorkflowsService(repo);
			const service = new WorkflowInstancesService(
				repo,
				mockNodeService,
				workflowsService,
				mockFeatureService,
			);

			// Create workflow and instance
			const workflowResult = await workflowsService.createWorkflow(adminCtx, {
				title: "Article Review",
				description: "Article review workflow",
				states: [
					{
						name: "draft",
						isInitial: true,
						transitions: [{ signal: "submit", targetState: "review" }],
					},
					{ name: "review", isFinal: true },
				],
				availableStateNames: ["draft", "review"],
				filters: [["mimetype", "==", "text/markdown"]],
				groupsAllowed: ["--editors--"],
			});

			expect(workflowResult.isRight()).toBe(true);
			if (!workflowResult.isRight()) return;

			const createResult = await service.createWorkflowInstance(editorCtx, {
				workflowDefinitionUuid: workflowResult.value.uuid,
				nodeUuid: "node-123",
				groupsAllowed: ["--editors--"],
			});

			expect(createResult.isRight()).toBe(true);
			if (!createResult.isRight()) return;

			// Try to update as user without permission
			const result = await service.updateWorkflowInstance(userCtx, createResult.value.uuid, {
				currentStateName: "review",
			});

			expect(result.isLeft()).toBe(true);
		});
	});

	describe("deleteWorkflowInstance", () => {
		it("should delete workflow instance as admin", async () => {
			const repo = new InMemoryConfigurationRepository();
			const workflowsService = new WorkflowsService(repo);
			const service = new WorkflowInstancesService(
				repo,
				mockNodeService,
				workflowsService,
				mockFeatureService,
			);

			// Create workflow and instance
			const workflowResult = await workflowsService.createWorkflow(adminCtx, {
				title: "Article Review",
				description: "Article review workflow",
				states: [
					{
						name: "draft",
						isInitial: true,
						transitions: [{ signal: "submit", targetState: "review" }],
					},
					{ name: "review", isFinal: true },
				],
				availableStateNames: ["draft", "review"],
				filters: [["mimetype", "==", "text/markdown"]],
				groupsAllowed: [],
			});

			expect(workflowResult.isRight()).toBe(true);
			if (!workflowResult.isRight()) return;

			const createResult = await service.createWorkflowInstance(adminCtx, {
				workflowDefinitionUuid: workflowResult.value.uuid,
				nodeUuid: "node-123",
				groupsAllowed: [],
			});

			expect(createResult.isRight()).toBe(true);
			if (!createResult.isRight()) return;

			// Delete instance
			const result = await service.deleteWorkflowInstance(adminCtx, createResult.value.uuid);

			expect(result.isRight()).toBe(true);

			// Verify it's gone
			const getResult = await service.getWorkflowInstance(adminCtx, createResult.value.uuid);
			expect(getResult.isLeft()).toBe(true);
		});

		it("should reject delete as non-admin", async () => {
			const repo = new InMemoryConfigurationRepository();
			const workflowsService = new WorkflowsService(repo);
			const service = new WorkflowInstancesService(
				repo,
				mockNodeService,
				workflowsService,
				mockFeatureService,
			);

			// Create workflow and instance
			const workflowResult = await workflowsService.createWorkflow(adminCtx, {
				title: "Article Review",
				description: "Article review workflow",
				states: [
					{
						name: "draft",
						isInitial: true,
						transitions: [{ signal: "submit", targetState: "review" }],
					},
					{ name: "review", isFinal: true },
				],
				availableStateNames: ["draft", "review"],
				filters: [["mimetype", "==", "text/markdown"]],
				groupsAllowed: [],
			});

			expect(workflowResult.isRight()).toBe(true);
			if (!workflowResult.isRight()) return;

			const createResult = await service.createWorkflowInstance(adminCtx, {
				workflowDefinitionUuid: workflowResult.value.uuid,
				nodeUuid: "node-123",
				groupsAllowed: [],
			});

			expect(createResult.isRight()).toBe(true);
			if (!createResult.isRight()) return;

			// Try to delete as non-admin
			const result = await service.deleteWorkflowInstance(userCtx, createResult.value.uuid);

			expect(result.isLeft()).toBe(true);
		});
	});
});
